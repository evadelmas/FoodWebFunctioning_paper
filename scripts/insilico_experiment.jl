#=
Feb. 26th 2020
Eva Delmas

This script uses the food web matrices generated by scripts/foodwebs_generation.jl
and simulate their biomass dynamics with the bio-energetic food web model
as implemented in the julia package BioEnergeticFoodWebs.jl

For each individual food web, we generate different hierarchies of competition
between the producers. This will allow us to test for a potential selection
effect.

All simulations outputs are stored in simulations_outputs/
=#

#REQUIREMENTS ==================================================================
using Distributed
addprocs(8)
@everywhere import Pkg
@everywhere Pkg.activate(pwd())
using NamedArrays
@everywhere using BioEnergeticFoodWebs, Distributions, JLD2
@everywhere import StatsBase.sample

!isdir("simulations_outputs/") ? mkdir("simulations_outputs/") : Nothing

#LOAD AND PREPARE THE DATA =====================================================

@load "data/adbm_generated_foodwebs.jld2" matrices_unique
#We will not use the original body sizes for this analysis
#as we want to be able to control it.
is_vertebrate = [] #retrieve metabolic status
for i in 1:length(matrices_unique)
    A = matrices_unique[i]
    tmp_metab = [split(names(A)[2][j], r"_")[2] for j = 1:size(A,1)]
    tmp_metab2 = [tmp_metab[j] .== "true" for j in 1:size(A,1)]
    append!(is_vertebrate, [tmp_metab2])
end
foodwebs = Array.(matrices_unique)

#INITIALIZE THE MODEL ==========================================================

#model parameters
p = pmap(
    (x,y) -> model_parameters(
        x
        #we sample the body-size ratio between consumer and prey from 0.01 to 100.0
        , Z = sample([0.01, 0.1, 1.0, 10.0, 100.0], 1)[1]
        #we keep the original metabolic status
        , vertebrates = y
        #producer growth is determined by a nutrient intake model (as in Brose et al., 2008)
        , productivity = :nutrients, supply = [4.0, 4.0]
        #functional response has a sigmoÃ¯d shape (Hill III)
        , h = 2.0
        )
    , foodwebs, is_vertebrate
    )
#we want to have producers with different efficiency at using the two
#provided nutrients, to do so, we set different half sat. densities K1 and K2
#(for the same network we will have 3 different hierarchies)
@everywhere n_hierarchy = 1
@everywhere function sample_halfsat(parameters; n::Int64 = 5)
    p_tmp = [deepcopy(parameters) for i = 1:n_hierarchy]
    k1 = map(x -> rand(Uniform(0.1,0.2), sum(x[:is_producer])), p_tmp)
    k_0 = map(x -> repeat([0], sum(.!x[:is_producer])), p_tmp)
    k1_all = vcat.(k1, k_0)
    k2 = map(x -> rand(Uniform(0.1,0.2), sum(x[:is_producer])), p_tmp)
    k2_all = vcat.(k2, k_0)
    for k in 1:length(p_tmp)
            p_tmp[k][:K1] = k1_all[k]
            p_tmp[k][:K2] = k2_all[k]
    end
    return p_tmp
end
p_all = pmap(x -> sample_halfsat(x, n = n_hierarchy), p)
parameters = vcat(p_all...)

#SIMULATIONS ===================================================================

@everywhere function simsave(p)
    #create an id for food webs
    np = sum(p[:is_producer])
    nc = sum(.!p[:is_producer])
    web_id = hash(p[:A])
    #create a unique name for the simulation
    unique_id = hash(p)
    simname = "sim" * string(unique_id) * ".jld2"
    #perform the simulation
    sim = simulate(p, rand(size(p[:A],1)), stop = 3000)
    #get the emerging network
    A = deepcopy(p[:A])
    nonextinct = trues(size(A,1))
    nonextinct[sim[:p][:extinctions]] .= false
    A_new = A[nonextinct, nonextinct]
    #check whether we have disconnected species, food web with no producer or
    #no secondary consumers
    is_connected = vec(sum(A_new, dims = 2) .!= 0) .| vec(sum(A_new, dims = 1) .!= 0)
    C = all(is_connected)
    is_producer = vec(sum(A_new, dims = 2) .== 0)
    P = any(is_producer)
    height = trophic_rank(A_new)
    H = any(height .> 2)
    #save only if all conditions are ok
    if (C & P & H)
        sim[:p][:newA] = A_new
        sim[:p][:id] = web_id
        @save "simulations_outputs/$simname" sim
    end
end

pmap(simsave, parameters)
